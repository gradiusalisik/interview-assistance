// // Путают с понятием скоуп. Скоуп указывается на видимость определённых переменных.
// //  Контекст определяет как функция была вызвана и он постоянно указывает на ключевое слово this в текущем участке кода с которым мы работаем.
// const person = {
//   surname: "Старк",
//   knows: function (what, name) {
//     console.log(`Ты ${what} знаешь, ${name} ${this.surname}`);
//   },
// };
// const john = { surname: "Сноу" };

// // Контекст в JS является объектом. **
// person.knows("всё", "Бран");
// // Ты всё знаешь, Бран Старк
// person.knows.call(john, "ничего не", "Джон");
// person.knows.call(john, ...["ничего не", "Джон"]);
// // Ты ничего не знаешь, Джон Сноу
// // Метод call работает следующим образом. Он сразу вызывает функцию, с переданным контекстом, но через запятую он принимает остальные параметры, которые нужны для этой функции.
// person.knows.apply(john, ["ничего не", "Джон"]);
// // Ты ничего не знаешь, Джон Сноу
// // Отличие от call в том, что у него всего два параметра. Второй параметр всегда массив аргументов, которые нужны для работы функции, в нашем случае knows
// person.knows.bind(john, "ничего не", "Джон")();
// // Ты ничего не знаешь, Джон Сноу
// const bound = person.knows.bind(john, "ничего не", "Джон");
// bound();
// // Ты ничего не знаешь, Джон Сноу

// // Как и call принимает первым аргументом, контекст. А потом принимает неограниченное количество аргументов, которые нужны для функции. Единственное отличие в том, что он не вызывает функцию сразу же, а он возвращает новую функцию.

// ====================
// function Person(name, age) {
//   this.name = name;
//   this.age = age;

//   console.log(this);
// }

// const elena = new Person("Елена", 20);
// // Person { name: 'Елена', age: 20 } - это вывод this. Он является инстансом класса Person

// ==================
// Явная передача контекста.
// function logThis() {
//   console.log(this);
// }

// const obj = {num: 42};
// logThis.apply(obj);
// logThis.call(obj);
// logThis.bind(obj)();

// ====================
// Неявная передача контекста.
// const animal = {
//   legs: 4,
//   logThis: function () {
//     console.log(this);
//   },
// };

// animal.logThis();
// { legs: 4, logThis: [Function: logThis] }
// Мы получим тот объект, в контексте которого был вызван данный метод. В данном случае у нас неявная привязка к контекста, потому что к функции logThis привязался контекст того объекта, в котором был вызыван этото метод.

// =====================
function Cat(color) {
  this.color = color;
  console.log("This", this);
  (() => console.log("Arrow this", this))();
}

new Cat("red");
// This Cat { color: 'red' }
// Arrow this Cat { color: 'red' }
// Стрелочная функция не создаёт свой собственный контекст

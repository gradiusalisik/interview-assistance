// Очень важно понимать разные контексты прототипа.
// 1. Каждый объект имеет свой прототип, который берётся от родительского элемента, от которого был создан данный объект. Для того чтобы  получить родительский прототип сейчас используется специальное ключевое слово __proto__
// Он указывает на прототип родителского класса или объекта от которого был создан данный объект.
// Безусловно стоит уточнить, что любое наследование в JS, существует как прототипированное наследование, когда всё идет по цепочке, по дереву. Существует базовый класс, то него создаются, допустим другие классы. И дальше, если мы обращаемся к свойству какого-либо объекта, то начинаем смотреть сначала на само свойство, если там нет его, то он смотрит на прототип, который является объектом, если там не находит, то он смотрит прототип прототипа этого объекта и так далее. Тут всё идёт именно по цепочке.

// __proto__ ES6
// Object.getPrototypeOf() ES5

// 2. Свойство prototype у различных функций. Который служит для того, чтобы передавать эти свойства для объекта, которые создаются допустим через ключевое слово new

// function Cat(name, color) {
//   this.name = name;
//   this.color = color;
// }

// Cat.prototype.voice = function () {
//   console.log(`Cat ${this.name} says meow`);
// };
// // Здесь мы обращаемся к ключевому слову this, которое (учитывая слово function даёт нам свой контекст) обращено к контексту класса Cat и говорит нам какой там голос.

// const cat = new Cat("Kot", "white");

// cat.voice();
// // Cat Kot says meow

// // Путем расширения протоипа родительского класса Cat, мы получили доступ к методу  voice - это работает через прототип.
// console.log(Cat.prototype);
// // { voice: [Function (anonymous)] }
// // Является указателем на обхект, в котором есть конструктор и соответствующие поля, которые будут добавлены для объекта, которые будут созданы для этого класса.
// console.log(cat);
// // Cat { name: 'Kot', color: 'white' }
// console.log(cat.__proto__ === Cat.prototype);
// // true

// =======================
// Свойства доступные в прототипе.
function Person() {}

Person.prototype.legs = 2;
Person.prototype.skin = "white";

const person = new Person();
person.name = "Vladislav";

console.log("skin" in person);
// true
// in проверяет, есть ли такое свойство в объекте или его прототипе.
console.log(person.legs);
// 2 потому что свойство legs доступно в прототипе данного объекта.

// Как определить какие свойства есть в объекте, а какие в его прототипе?
console.log(person.hasOwnProperty("name"));
// true
console.log(person.hasOwnProperty("skin"));
// false

// hasOwnProperty проверяет есть ли свойство в самом объекте.

// =================
// Object.crate(); позволяет создавать нам некотоыре объекты, использующие уже существующий прототип.
let proto = { year: 2020 };
const myYear = Object.create(proto);

// console.log(myYear.year);
// // 2020

// console.log(myYear.hasOwnProperty("year"));
// // false потому что он взят из прототипа.

// console.log(myYear.__proto__ === proto);
// true Потому что данный объект сейчас является прототипом, так как мы использовали функцию Object.create();

// Здесь присутствует одна особенность, которую стоит учитывать.
// 1.
// proto.year = 2000;
// console.log(myYear.year);
// 2000

// 2.
proto = { year: 1999 };
console.log(myYear.year);
// 2020 мы закомментировали код, осталось только первое объявление и здесь изменений. Оно раньше работало по другому, но сейчас зафиксировали интерпретатор и он не меняет значение таким образом..
